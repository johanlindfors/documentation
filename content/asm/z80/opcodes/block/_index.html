---
type: "manual"
title: "Block Copy or Search of memory"
linkTitle: "Block LD/CP"
weight: 3
description: "Copy or search block of memory"
tags:
  - z80 instruction
code_format: "%[2]s %[3]s"
code_source: ""
code_destination: ""
code_includeop: true
code_axis:
  - Increment
  - Decrement
code_dest:
  - Single Copy
  - Repeat Copy
  - Single Search
  - Repeat Search
codes:
  - op: "LDI"
    code: "EDA0"
    colour: yellow
    match: "Single Copy Increment"
    size: 2
    cycles: 4,4,3,5
  - op: "LDIR"
    code: "EDB0"
    colour: yellow
    match: "Repeat Copy Increment"
    size: 2
    cycles: 4,4,3,5,5
  - op: "LDD"
    code: "EDA8"
    colour: yellow
    match: "Single Copy Decrement"
    size: 2
    cycles: 4,4,3,5
  - op: "LDDR"
    code: "EDB8"
    colour: yellow
    match: "Repeat Copy Decrement"
    size: 2
    cycles: 4,4,3,5,5

  - op: "CPI"
    code: "EDA1"
    colour: yellow
    match: "Single Search Increment"
    size: 2
    cycles: 4,4,3,5
  - op: "CPIR"
    code: "EDB1"
    colour: yellow
    match: "Repeat Search Increment"
    size: 2
    cycles: 4,4,3,5,5
  - op: "CPD"
    code: "EDA9"
    colour: yellow
    match: "Single Search Decrement"
    size: 2
    cycles: 4,4,3,5
  - op: "CPDR"
    code: "EDB9"
    colour: yellow
    match: "Repeat Search Decrement"
    size: 2
    cycles: 4,4,3,5,5

---

<h2>Memory Block Instructions</h2>

<p>
  The Block transfer instructions allow for data to be moved around in memory.
  The programmer needs to configure the 16 bit registers to define the properties of the move:
  <code>HL</code> is the source address to copy from;
  <code>BC</code> is the number of bytes to copy.
</p>
<p>
  For block copy operations <code>LDI*</code> and <code>LDD*</code> then
  <code>DE</code> is also set to the destination address of the copy.
  For block compare operations <code>CPI*</code> and <code>CPD*</code> then
  <code>A</code> is set to the value to search for.
</p>

{{< z80/instruction
operation="\begin{rcases} A - (HL) \text{ if } S=1 \\ HL \longleftarrow HL+1 \text{ if } D = 0\\HL \longleftarrow HL-1 \text{ if } D = 1\\ DE \longleftarrow DE+1 \text{ if } D=0 \And S=0\\DE \longleftarrow DE-1 \text{ if } D=1 \And S=0\\BC \longleftarrow BC-1 \end{rcases} \text{repeat while } \begin{cases} L=1\\BC \not = 0\\ A \not = (HL) \text{ if } S=1 \end{cases}"
def="11101101 ED/101LD00S"
>}}
{{< /z80/instruction >}}
<p>
  <strong>S</strong> 0=copy memory, 1=search memory
</p>
<p>
  <strong>D</strong> 0=Increment, 1=Decrement <code>HL</code> after each iteration.
</p>
<p>
  <strong>L</strong> If set then if  \( BC \not = 0 \) at the end if the instruction then \( PC \longleftarrow PC - 2 \)
  So that the instruction is repeated.<br/>
  If BC=0 at start of a repeatable instruction then 65536 iterations will occur.
</p>

<div class="row">
  <div class="col-6">
    <h2>Block copy</h2>
    <p>
      The <code>LD*</code> instructions then perform the equivalent of the following:
    </p>
    <ol>
      <li>Copy a byte of memory from <code>(HL)</code> to <code>(DE)</code></li>
      <li>Decrement <code>BC</code> by one</li>
      <li><code>HL</code> and <code>DE</code> are either incremented (for LDI/LDIR) or decremented (for LDD/LDDR) by
        one.
      </li>
      <li>The <code>LDIR</code> and <code>LDDR</code> instructions will loop back to step one if \( BC \not = 0 \)</li>
    </ol>
  </div>
  <div class="col-6">
    <h2>Block compare</h2>

    <p>
      The <code>CP*</code> instructions compare memory against the Accumulator
    </p>
    <ol>
      <li>Calculate difference between <code>A</code> and content of memory in <code>(HL)</code> to set/clear Z flag
      </li>
      <li>Decrement <code>BC</code> by one</li>
      <li><code>HL</code> is either incremented (for CPI/CPIR) or decremented (for CPD/CPDR) by one.</li>
      <li>
        The CPIR and CPDR instructions will loop back to step one if \( A-(HL) \not = 0 \And BC \not = 0 \)<br/>
        If the value was found them HL will be set to the byte after or before it depending on the direction being used.
      </li>
    </ol>
  </div>
</div>

<div>
  <h2>Timing</h2>
  <p>
    For the non-repeating instructions, they take 16(4,4,3,5) T-States to execute.
  </p>
  <p>
    For the repeating instructions, they take either 21(4,4,3,5,5) T-States when they loop
    and 16(4,4,3,5) T-States when terminating.
  </p>
  <p>
    Also note, that for these instructions the timing is for each iteration, not for the entire run.
    So if LDIR is run with BC=4 then the number of T-States for the entire operation would take
    79(21+21+21+16) T-States.
  </p>
</div>