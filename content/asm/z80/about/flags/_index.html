---
type: "manual"
title: "Z80 Status Flags"
linkTitle: "Flags"
weight: 15
---
<p>
    The Flag registers, F and F', supply information to the user about the status of the Z80
    CPU at any particular time.
    Each of these two Flag registers contains 6 bits of status information that are set or cleared
    by CPU operations; bits 3 and 5 are not used.
</p>
<p>
    Four of these bits (C, P/V, Z, and S) can be tested for use with conditional JUMP, CALL, or RETURN instructions.
</p>
<p>
    The H and N flags cannot be tested; these two flags are used for BCD arithmetic.
</p>

<div>
    <table class="memoryMap4">
        <thead>
        <tr>
            <th>7</th>
            <th>6</th>
            <th>5</th>
            <th>4</th>
            <th>3</th>
            <th>2</th>
            <th>1</th>
            <th>0</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td class="brb blue">S</td>
            <td class="brb blue">Z</td>
            <td class="brb"></td>
            <td class="brb grey">H</td>
            <td class="brb"></td>
            <td class="brb blue">P/V</td>
            <td class="brb grey">N</td>
            <td class="brb blue">C</td>
        </tr>
        </tbody>
    </table>
</div>

<div class="printPageBreakAvoid">
    <h3>C Carry</h3>
    <p>
        The Carry Flag (C) is set or cleared depending on the operation being performed.
    </p>
    <p>
        For ADD instructions that generate a Carry, and for SUB instructions that generate a Borrow, the Carry Flag is
        set.
    </p>
    <p>
        The Carry Flag is reset by an ADD instruction that does not generate a Carry, and by a SUB instruction that does
        not
        generate a Borrow.
    </p>
    <p>
        This saved Carry facilitates software routines for extended precision arithmetic.
    </p>
    <p>
        Additionally, the DAA instruction sets the Carry Flag if the conditions for making the decimal adjustment are
        met.
    </p>
    <p>
        For the RLA, RRA, RLS, and RRS instructions, the Carry bit is used as a link between the
        least-significant byte (LSB) and the most-significant byte (MSB) for any register or memory location.
        During the RLCA, RLC, and SLA instructions, the Carry flag contains the final value shifted out of bit 7 of any
        register or memory location.
        During the RRCA, RRC, SRA, and SRL instructions, the Carry flag contains the final value shifted out of bit 0 of
        any
        register or memory location.
    </p>
    <p>
        For the logical instructions AND, OR, and XOR, the Carry flag is reset.
    </p>
    <p>
        The Carry flag can also be set by the Set Carry Flag (SCF) instruction and complemented by the Compliment Carry
        Flag
        (CCF) instruction.
    </p>
</div>

<div class="printPageBreakAvoid">
    <h3>Z Zero</h3>
    <p>
        The Zero Flag (Z) is set (1) or cleared (0) if the result generated by the execution of certain instructions is
        0.
    </p>
    <p>
        For 8-bit arithmetic and logical operations, the Z flag is set to a 1 if the resulting byte in the Accumulator
        is 0. If the byte is not 0, the Z flag is reset to 0.
    </p>
    <p>
        For Compare (search) instructions, the Z flag is set to 1 if the value in the Accumulator is equal to the value
        in the memory location indicated by the value of the register pair HL.
    </p>
    <p>
        When testing a bit in a register or memory location, the Z flag contains the complemented state of the indicated
        bit.
    </p>
    <p>
        When inputting or outputting a byte between a memory location and an INI, IND, OUTI, or OUTD I/O device, if the
        result of decrementing Register B is 0, then the Z flag is 1; otherwise, the Z flag is 0.
        Additionally, for byte inputs from I/O devices using IN r, (C), the Z flag is set to indicate a 0-byte input.
    </p>
</div>

<div class="printPageBreakAvoid">
    <h3>P/V Parity Overflow</h3>
    <p>
        The Parity/Overflow (P/V) Flag is set to a specific state depending on the operation being performed.
    </p>
    <h4>Overflow</h4>
    <p>
        For arithmetic operations, this flag indicates an overflow condition when the result in the Accumulator is
        greater than the maximum possible number (+127) or is less than the minimum possible number (–128).
        This overflow condition is determined by examining the sign bits of the operands.
    </p>
    <p>
        For addition, operands with different signs never cause overflow.
        When adding operands with similar signs and the result contains a different sign, the Overflow Flag is set.
    </p>
    <p>
        For subtraction, overflow can occur for operands of unalike signs. Operands of alike signs never cause overflow.
    </p>
    <p>
        Another method for identifying an overflow is to observe the Carry to and out of the sign bit.
        If there is a Carry in and no Carry out, or if there is no Carry in and a Carry out, then an Overflow has
        occurred.
    </p>
    <h4>Parity</h4>
    <p>
        This flag is also used with logical operations and rotate instructions to indicate the resulting parity is even.
        The number of 1 bits in a byte are counted.
        If the total is Odd, ODD parity is flagged (i.e., P = 0).
        If the total is even, even parity is flagged (i.e., P = 1).
    </p>
    <p>
        When inputting a byte from an I/O device with an IN r, (C) instruction, the P/V Flag is adjusted to indicate
        data parity.
    </p>
    <h4>Alternate usage</h4>
    <p>
        During the CPI, CPIR, CPD, and CPDR search instructions and the LDI, LDIR, LDD, and LDDR block transfer
        instructions, the P/V Flag monitors the state of the Byte Count (BC) Register.
        When decrementing, if the byte counter decrements to 0, the flag is cleared to 0; otherwise the flag is set to
        1.
    </p>
    <p>
        During the LD A, I and LD A, R instructions, the P/V Flag is set with the value of the interrupt enable
        flip-flop (IFF2) for storage or testing.
    </p>
    <p>
    </p>
</div>

<div class="printPageBreakAvoid">
    <h3>S Sign</h3>
    <p>
        The Sign Flag (S) stores the state of the most-significant bit of the Accumulator (bit 7).
        When the Z80 CPU performs arithmetic operations on signed numbers, the binary twos-complement notation is used
        to represent and process numeric information.
    </p>
    <p>
        A positive number is identified by a 0 in Bit 7.
        A negative number is identified by a 1.
    </p>
    <p>
        The binary equivalent of the magnitude of a positive number is stored in bits 0 to 6 for a total range of from 0
        to 127.
    </p>
    <p>
        A negative number is represented by the twos complement of the equivalent positive number.
        The total range for negative numbers is from –1 to –128.
    </p>
    <p>
        When inputting a byte from an I/O device to a register using an IN r, (C) instruction, the S
        Flag indicates either positive (S = 0) or negative (S = 1) data.
    </p>
</div>

<div class="printPageBreakAvoid">
    <h3>N Add/Subtract</h3>
    <p>
        The Add/Subtract Flag (N) is used by the Decimal Adjust Accumulator instruction (DAA) to distinguish between the
        ADD and SUB instructions.
    </p>
    <p>
        For ADD instructions, N is cleared to 0.
        For SUB instructions, N is set to 1.
    </p>
</div>

<div class="printPageBreakAvoid">
    <h3>H Half Carry</h3>
    <p>
        The Half Carry Flag (H) is set (1) or cleared (0) depending on the Carry and Borrow status between bits 3 and 4
        of an 8-bit arithmetic operation.
        This flag is used by the Decimal Adjust Accumulator (DAA) instruction to correct the result of a packed BCD add
        or subtract operation.
    </p>
    <p>
        For ADD instructions, H is set if a carry occurs from bit 3 to bit 4.
        For SUB instructions, H is set if a borrow from bit 4 occurs.
    </p>
</div>

<div class="printPageBreakAvoid">
    <h3></h3>
    <p>
    </p>
    <p>
    </p>
</div>

<div class="printPageBreakAvoid">
    <h3></h3>
    <p>
    </p>
    <p>
    </p>
</div>

<div class="printPageBreakAvoid">
    <h3></h3>
    <p>
    </p>
    <p>
    </p>
</div>
